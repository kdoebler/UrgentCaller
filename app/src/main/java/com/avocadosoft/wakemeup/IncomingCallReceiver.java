package com.avocadosoft.wakemeup;

import java.text.SimpleDateFormat;
import java.util.Date;
import java.util.Locale;
import android.content.BroadcastReceiver;
import android.content.Context;
import android.content.Intent;
import android.content.SharedPreferences;
import android.content.res.Resources;
import android.media.AudioManager;
import android.telephony.PhoneStateListener;
import android.telephony.TelephonyManager;
import android.util.Log;

public class IncomingCallReceiver extends BroadcastReceiver
{
	private Context mContext;
	private Resources resources;
	private SharedPreferences preferences;
	private TelephonyManager telephonyManager;
	private WakeMeUpPreferences wakeUpPreferences;
	private AudioManager audio;
	
	private int missedCallCount;
	private int missedCallThreshold;
	private int streamRing;
	private int streamMaxVolume;
	public static int totalMissedCallsSinceLastPickup;
	
	public static boolean respondedToCall;
	public static boolean wasRinging;
	public static boolean missedCall;
	

	public static final String inputFormat = "HH:mm";

	private Date date;
	private Date dateCompareOne;
	private Date dateCompareTwo;

	SimpleDateFormat inputParser = new SimpleDateFormat(inputFormat, Locale.US);

	public IncomingCallReceiver()
	{
		// We need an empty constructor. I assumed an empty constructor is
		// generated by the compiler like .net
		// but I received an error when I did not have one.
	}

	//Constructor for this class.
	//This receives the arguments and sets up the variables used.
	//This should only be called once, when the service is started.
	public IncomingCallReceiver(TelephonyManager tm, Context context)
	{
		//Create local copy of variables
		mContext = context;
		resources = context.getResources();
		telephonyManager = tm;
		preferences = context.getSharedPreferences(resources.getString(R.string.userPreferencesFileName), 0);
		wakeUpPreferences = new WakeMeUpPreferences(context);

		// This variable holds the events we want the TelephonyManager class to listen for.
		// In this case, we want to listen for changes to the device call state.
		int events = PhoneStateListener.LISTEN_CALL_STATE;
		
		// This creates the listener using the event we just defined.
		telephonyManager.listen(phoneStateListener, events);
		
		// We need to know how many calls the user is willing to miss before the volume is turned up.
		missedCallThreshold = preferences.getInt(resources.getString(R.string.userPreferencesCallCountThresholdKeyName), 3);
		
		// In case they rebooted the phone or it crashed, we check to see if there's any missed calls at the moment.
		missedCallCount = preferences.getInt(resources.getString(R.string.userPreferencesMissedCallCount), 0);
		
		// Get a reference to the Android audio manager.  This is used to raise the volume.
		audio = (AudioManager) mContext.getSystemService(Context.AUDIO_SERVICE);
		
		// Get a reference to the audio stream for the phone ring
		streamRing = AudioManager.STREAM_RING;
		
		// Get the maximum volume index for the referenced stream.  This is used when we increase the ringer volume.
		streamMaxVolume = audio.getStreamMaxVolume(AudioManager.STREAM_RING);
	}

	@Override
	public void onReceive(Context context, Intent intent)
	{

	}

	

	private Date parseDate(String date)
	{
		try
		{
			return inputParser.parse(date);
		}
		catch (java.text.ParseException e)
		{
			return new Date(0);
		}
	}

	//This function determines if we are currently within the users selected window in which
	//they want this program to run. In this case, we only look at the missed calls if we're in their window.
	private Boolean compareDates()
	{
		//A whole lot of date work that can probably be improved.
		SimpleDateFormat sdf = new SimpleDateFormat("HH:mm:ss");
		String str = sdf.format(new Date());
		date = parseDate(str);

		Date currentDateTime = new Date();

		//Set up date object for the beginning of the user window.
		Date beginWindowDate = new Date();
		String beginWindowTime = preferences.getString(resources.getString(R.string.userPreferencesBeginTimeKeyName), "23:00");
		int beginWindowHour = Integer.parseInt(beginWindowTime.substring(0, beginWindowTime.indexOf(":")));
		int beginWindowMinute = Integer.parseInt(beginWindowTime.substring(beginWindowTime.indexOf(":") + 1, beginWindowTime.length()));
		beginWindowDate.setHours(beginWindowHour);
		beginWindowDate.setMinutes(beginWindowMinute);

		//Set up date object for the end of the user window.
		Date endWindowDate = new Date();
		String endWindowTime = preferences.getString(resources.getString(R.string.userPreferencesEndTimeKeyName), "23:00");
		int endWindowHour = Integer.parseInt(endWindowTime.substring(0, endWindowTime.indexOf(":")));
		int endWindowMinute = Integer.parseInt(endWindowTime.substring(endWindowTime.indexOf(":") + 1, endWindowTime.length()));
		endWindowDate.setHours(endWindowHour);
		endWindowDate.setMinutes(endWindowMinute);
		//We only store the time in the preferences file. Given this, sometimes the end window time is before the begin window time.
		//In this case, we need to add a day onto the end date so it makes sense.
		if (endWindowDate.before(beginWindowDate))
			endWindowDate.setDate(endWindowDate.getDate() + 1);

		// Now that we've set up our date objects, we need to compare them to the current date time.  
		// Return true if we're within the date window, false if we're not.
		if (beginWindowDate.before(currentDateTime) && endWindowDate.after(currentDateTime))
		{
			return true;
		}
		else
		{
			WakeMeUpPreferences.setCallCount(0);
			return false;
		}
	}

	//PhoneStateListener class.  This is whats called when the phone rings (or when the state changes, more specifically.)
	private final PhoneStateListener phoneStateListener = new PhoneStateListener()
	{
		@Override
		public void onCallStateChanged(int state, String incomingNumber)
		{
			//The phone state has changed. We only care if we are within the users active window.
			
			//If always on

			if (WakeMeUpPreferences.getAlwaysOn() == false)
			{
				Boolean withinWindow = compareDates();
				
				//Turn back if we're not within the window.
				if (withinWindow == false)
					return;	
			}

			
			//We NO LONGER CARE ABOUT DATES. IF THIS IS RUNNING, THE WAKEMEUPALARM HAS CHECKED EVERYTHING

			switch (state)
				{
				case TelephonyManager.CALL_STATE_IDLE:
					// When the call state is idle and wasRinging = true, it means we just missed a call.
					// Increment the missed call count
					if (wasRinging)
					{
						if (respondedToCall == false)
						{
							missedCallCount++;
							WakeMeUpPreferences.setCallCount(missedCallCount);
							WakeMeUpPreferences.setLastCallDateTime(new Date());
						}
					}

					break;

				case TelephonyManager.CALL_STATE_RINGING:
					//The phone is ringing. We track this so we know if they missed a call.
					wasRinging = true;

					// Here is where we actually raise the volume.
					// If the current missed call count is at least equal to their threshold, we want to max out the volume.
					if (missedCallCount >= missedCallThreshold - 1)
					{
						audio.setStreamVolume(streamRing, streamMaxVolume, AudioManager.FLAG_ALLOW_RINGER_MODES | AudioManager.FLAG_PLAY_SOUND);
					}
					break;

				case TelephonyManager.CALL_STATE_OFFHOOK:
					// A state of "offhook" after a state of "ringing" means they picked up the phone.
					// This means we are within their window, but they acknowledged the call.  
					// Reset the missed call count back to zero.
					if (wasRinging)
					{
						respondedToCall = true;
						WakeMeUpPreferences.setCallCount(0);
					}

					break;
				}

			super.onCallStateChanged(state, incomingNumber);
		}
	};

}